<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><link href="css/default.css" rel="stylesheet" type="text/css" /><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>com.lemondronor.turboshrimp.pave documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Turboshrimp</span> <span class="project-version">2.0.3</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="intro.html"><div class="inner"><span>Introduction to turboshrimp</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 "><a href="com.lemondronor.turboshrimp.html"><div class="inner"><span>com.lemondronor.turboshrimp</span></div></a></li><li class="depth-1 "><a href="com.lemondronor.turboshrimp.at.html"><div class="inner"><span>com.lemondronor.turboshrimp.at</span></div></a></li><li class="depth-1 current"><a href="com.lemondronor.turboshrimp.pave.html"><div class="inner"><span>com.lemondronor.turboshrimp.pave</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="com.lemondronor.turboshrimp.pave.html#var-dropped-frame-count"><div class="inner"><span>dropped-frame-count</span></div></a></li><li class="depth-1"><a href="com.lemondronor.turboshrimp.pave.html#var-make-frame-queue"><div class="inner"><span>make-frame-queue</span></div></a></li><li class="depth-1"><a href="com.lemondronor.turboshrimp.pave.html#var-pull-frame"><div class="inner"><span>pull-frame</span></div></a></li><li class="depth-1"><a href="com.lemondronor.turboshrimp.pave.html#var-queue-frame"><div class="inner"><span>queue-frame</span></div></a></li><li class="depth-1"><a href="com.lemondronor.turboshrimp.pave.html#var-read-frame"><div class="inner"><span>read-frame</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">com.lemondronor.turboshrimp.pave</h1><div class="doc"><div class="markdown"><p>Code for reading and parsing video data in Parrot Video Encapsulated (PaVE) format, which is the format of the drone’s video stream.</p>
<p>Typically you will do something like the following to process drone video:</p>
<ul>
  <li>
  <p>Create a frame queue (<a href="com.lemondronor.turboshrimp.pave.html#var-make-frame-queue">make-frame-queue</a>), a video input stream (<a href="com.lemondronor.turboshrimp.html#var-video-input-stream">video-input-stream</a>), and a video decoder (see e.g. the <a href="https://github.com/wiseman/turboshrimp-xuggler">turboshrimp-xuggler</a> library).</p></li>
  <li>
  <p>Create a thread that calls <a href="com.lemondronor.turboshrimp.pave.html#var-read-frame">read-frame</a> on the input stream and uses <a href="com.lemondronor.turboshrimp.pave.html#var-queue-frame">queue-frame</a> to put frames in the queue.</p></li>
  <li>
  <p>Create another thread that uses <a href="com.lemondronor.turboshrimp.pave.html#var-pull-frame">pull-frame</a> to get a video frame from the queue and then uses the decoder to decode the frame into an image.</p></li>
</ul>
<p>The following example code follows this pattern. It also puts the decoded images into an async channel, from which presumably another thread will get the images and display them on screen.</p>
<pre><code>(let [queue (pave/make-frame-queue)
      input-stream (turboshrimp/video-input-stream my-drone)
      decoder (xuggler/decoder)
      ;; Create an async channel with a sliding buffer of size 1; If
      ;; our image rendering is slow this will drop frames, which is
      ;; good.
      image-channel (async/chan (async/sliding-buffer 1))]
  (doto (Thread.
         (fn []
           (loop [frame (pave/read-frame input-stream)]
             (when frame
               (pave/queue-frame queue frame))
             (recur (pave/read-frame input-stream)))))
    (.start))
  (doto (Thread.
         (fn []
           (loop [frame (pave/pull-frame queue 1000)]
             (when frame
               (let [^BufferedImage image (decoder frame)]
                 (a/go
                   (a/&gt;! image-channel image))))
             (recur (pave/pull-frame queue 1000)))))
    (.start)))
</code></pre></div></div><div class="public anchor" id="var-dropped-frame-count"><h3>dropped-frame-count</h3><div class="usage"><code>(dropped-frame-count queue)</code></div><div class="doc"><div class="markdown"><p>Returns the number of video frames that have been dropped in order to reduce latency.</p></div></div><div class="src-link"><a href="https://github.com/wiseman/turboshrimp/blob/2.0.3/src/com/lemondronor/turboshrimp/pave.clj#L188">view source</a></div></div><div class="public anchor" id="var-make-frame-queue"><h3>make-frame-queue</h3><div class="usage"><code>(make-frame-queue &amp; {:keys [reduce-latency?], :or {reduce-latency? true}})</code></div><div class="doc"><div class="markdown"><p>A frame queue that implements latency reduction by default.</p>
<p>This queue implements the recommended latency reduction technique for AR.Drone video, which is to drop any unprocessed P-frames whenever an I-frame is received.</p>
<p>To turn off latency reduction, you can call this with <code>:reduce-latency? false</code>.</p></div></div><div class="src-link"><a href="https://github.com/wiseman/turboshrimp/blob/2.0.3/src/com/lemondronor/turboshrimp/pave.clj#L168">view source</a></div></div><div class="public anchor" id="var-pull-frame"><h3>pull-frame</h3><div class="usage"><code>(pull-frame queue &amp; [timeout-ms])</code></div><div class="doc"><div class="markdown"><p>Pulls a video frame from a frame queue.</p>
<p>Blocks until a frame is available. An optional timeout (in milliseconds) can be specified, in which case the call will return nil if a frame isn’t available in time.</p></div></div><div class="src-link"><a href="https://github.com/wiseman/turboshrimp/blob/2.0.3/src/com/lemondronor/turboshrimp/pave.clj#L195">view source</a></div></div><div class="public anchor" id="var-queue-frame"><h3>queue-frame</h3><div class="usage"><code>(queue-frame queue frame)</code></div><div class="doc"><div class="markdown"><p>Pushes a video frame into a frame queue.</p></div></div><div class="src-link"><a href="https://github.com/wiseman/turboshrimp/blob/2.0.3/src/com/lemondronor/turboshrimp/pave.clj#L223">view source</a></div></div><div class="public anchor" id="var-read-frame"><h3>read-frame</h3><div class="usage"><code>(read-frame is)</code></div><div class="doc"><div class="markdown"><p>Reads a PaVE frame from an <code>InputStream</code>.</p>
<p>Skips over non-PaVE frames and returns the next PaVE frame. Returns nil if there are no more frames.</p></div></div><div class="src-link"><a href="https://github.com/wiseman/turboshrimp/blob/2.0.3/src/com/lemondronor/turboshrimp/pave.clj#L113">view source</a></div></div></div></body></html>